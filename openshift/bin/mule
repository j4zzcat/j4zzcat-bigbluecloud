#! /usr/bin/env ruby

require 'tempfile'
require 'open3'
require 'docopt'

ENV[ 'IBMCLOUD_COLOR' ] = 'false'

    HOME_DIR = File.expand_path( "#{File.dirname __FILE__}/.." )
     RUN_DIR = Dir.pwd
  STATE_FILE = "#{RUN_DIR}/terraform.tfstate"
SSH_KEYS_DIR = "#{RUN_DIR}/ssh-keys"

def ibmcloud_cli_init( region )
  %x[ ibmcloud login -r #{region}
      ibmcloud is target --gen 2 ]
end

def terraform_init
  if !File.exist? '.terraform'
    %x[ echo 'provider "ibm" {}' > dummy.tf
        terraform init
        rm dummy.tf ]
  end
end

def terraform( dir, vars = nil )
  plan_dir  = "#{HOME_DIR}/lib/modules/#{dir}"
  vars_file = "#{RUN_DIR}/#{dir}.auto.tfvars"

  # write vars
  if !vars.nil?
    puts "Writing #{vars_file}..."
    File.open vars_file, 'w' do | f |
      vars.each do | k, v |
        f.write "#{k} = \"#{v}\"\n"
      end
    end
  end

  var_files_option = ""
  Dir.glob( "#{RUN_DIR}/*.auto.tfvars" ) do | f |
    var_files_option += "-var-file=#{f} "
  end

  # prepare command
  puts "Running terraform..."
  cmd = <<-EOT.gsub( /\s+/, ' ' ).strip
    terraform apply
      -auto-approve
      -state #{STATE_FILE}
      -compact-warnings
      #{var_files_option}
      #{plan_dir}
  EOT

  puts cmd

  # run terraform
  status = nil
  Open3.popen2e( cmd ) do | stdin, stdout_err, wait_thread |
    while line = stdout_err.gets
      puts line
    end
    status = wait_thread.value
  end

  status.exitstatus
end # terraform

# ---- MAIN ----

usage = <<~DOC
  NAME:
    mule - Create simple openshift v4.3 cluster on IBM Cloud

  USAGE:
    mule new cluster --name=<name> --location=<loc>... --resource-group=<rg>
    mule new node    --name=<name> --type=<type>
    mule rm  node    --name=<name> [--force]

  OPTIONS:
    --name=<name>           The name of the newly created resource
    --location=<loc>        The location of the resource, given as region:zone[:subnet]
    --resource-group=<rg>   The name of the resource group to put the resources in
    --type=<type>           The type of the node, one of (master|worker)
  DOC

begin
  options = Docopt::docopt( usage )
rescue Docopt::Exit => e
  puts usage
  exit 1
end

if options[ 'new' ]

  # new cluster
  if options[ 'cluster' ]
    puts "Creating new cluster..."

    name           = options[ '--name' ]
    resource_group = options[ '--resource-group' ]

    locations = options[ '--location' ]
    quit 'Error, only a single location is supported at this time' if locations.size != 1
    region, zone = locations[ 0 ].split ':'

    Dir.mkdir SSH_KEYS_DIR if !File.exist? SSH_KEYS_DIR
    admin_private_key = "#{SSH_KEYS_DIR}/#{name}.rsa"
    admin_public_key  = "#{admin_private_key}.pub"

    if !File.exist? admin_private_key
      puts "Generating new ssh key..."
      %x[ ssh-keygen -t rsa -b 4096 -N "" -f #{admin_private_key} ]
    end

    ibmcloud_cli_init( region )
    terraform_init()

    terraform 'vpc-infra', {
      :resource_group_name => resource_group,
      :vpc_name            => name,
      :region_name         => region,
      :zone_name           => zone,
      :admin_public_key    => admin_public_key }

    subnet_1_id = %x[ ibmcloud is subnets | tail -n +3 | awk '{ if ($2 == "subnet-1" && $8 == "#{name}") { print $1} }' ].chomp

    terraform 'installation-server', {
      :vpc_name  => name,
      :subnet_id => subnet_1_id
    }

  end

elsif options[ 'add' ]
  puts 'Not implemented yet'
  exit 1

elsif options[ 'rm' ]
  puts 'Not implemented yet'
  exit 1

end

exit 0
