#! /usr/bin/env ruby

require 'tempfile'
require 'open3'
require 'docopt'

class CommandLine
  @usage = <<~DOC
    NAME:
      mule - Create a simple openshift v4.3 cluster on IBM Cloud

    USAGE:
      mule new cluster --name=<name> --location=<loc> --resource-group=<rg>
      mule new node    --name=<name> --type=<type>
      mule rm  node    --name=<name> [--force]

    OPTIONS:
      --name=<name>           The name of the newly created resource
      --location=<loc>        The location of the resource, given as region:zone
      --resource-group=<rg>   The name of the resource group to put the resources in
      --type=<type>           The type of the node, one of (master|worker)
    DOC

  def process()
    begin
      options = Docopt::docopt( usage )
    rescue Docopt::Exit => e
      puts usage
      exit 1
    end
  end
end




# ENV[ 'IBMCLOUD_COLOR' ] = 'false'
#
#     HOME_DIR = File.expand_path( "#{File.dirname __FILE__}/.." )
#      RUN_DIR = Dir.pwd
#    STATE_DIR = "#{RUN_DIR}"
# SSH_KEYS_DIR = "#{RUN_DIR}/ssh-keys"
#
# def ibmcloud_cli_init( region )
#   %x[ ibmcloud login -r #{region}
#       ibmcloud is target --gen 2 ]
# end
#
# def terraform_init
#   if !File.exist? '.terraform'
#     %x[ echo 'provider "ibm" {}' > dummy.tf
#         terraform init
#         rm dummy.tf ]
#   end
# end
#
# def terraform( dir, vars = nil )
#   plan_dir  = "#{HOME_DIR}/lib/modules/#{dir}"
#   vars_file = "#{RUN_DIR}/#{dir}.tfvars"
#
#   # write vars
#   if !vars.nil?
#     puts "Writing #{vars_file}..."
#     File.open vars_file, 'w' do | f |
#       vars.each do | k, v |
#         if v.is_a? Hash
#           v_s = ""
#           v.each { | k1, v1 | v_s += "#{k1} = \"#{v1}\"\n" }
#           f.write "#{k} = {\n#{v_s}}"
#         else
#           f.write "#{k} = \"#{v}\"\n"
#         end
#       end
#     end
#   end
#
#   var_files_option = ""
#   Dir.glob( "#{RUN_DIR}/*.tfvars" ) do | f |
#     var_files_option += "-var-file=#{File.basename f} "
#   end
#
#   # prepare command
#   puts "Running terraform..."
#   cmd = <<-EOT.gsub( /\s+/, ' ' ).strip
#     terraform apply
#       -auto-approve
#       -state #{STATE_DIR}/#{dir}.tfstate
#       -compact-warnings
#       #{var_files_option}
#       #{plan_dir}
#   EOT
#
#   puts cmd
#
#   # run terraform
#   status = nil
#   Open3.popen2e( cmd ) do | stdin, stdout_err, wait_thread |
#     while line = stdout_err.gets
#       puts line
#     end
#     status = wait_thread.value
#   end
#
#   status.exitstatus
# end # terraform
#
# # ---- MAIN ----
#
# usage = <<~DOC
#   NAME:
#     mule - Create simple openshift v4.3 cluster on IBM Cloud
#
#   USAGE:
#     mule new cluster --name=<name> --location=<loc>... --resource-group=<rg>
#     mule new node    --name=<name> --type=<type>
#     mule rm  node    --name=<name> [--force]
#
#   OPTIONS:
#     --name=<name>           The name of the newly created resource
#     --location=<loc>        The location of the resource, given as region:zone[:subnet]
#     --resource-group=<rg>   The name of the resource group to put the resources in
#     --type=<type>           The type of the node, one of (master|worker)
#   DOC
#
# begin
#   options = Docopt::docopt( usage )
# rescue Docopt::Exit => e
#   puts usage
#   exit 1
# end
#
# if options[ 'new' ]
#
#   # new cluster
#   if options[ 'cluster' ]
#     puts "Creating new cluster..."
#
#     name           = options[ '--name' ]
#     resource_group = options[ '--resource-group' ]
#
#     locations = options[ '--location' ]
#     quit 'Error, only a single location is supported at this time' if locations.size != 1
#     region, zone = locations[ 0 ].split ':'
#
#     Dir.mkdir SSH_KEYS_DIR if !File.exist? SSH_KEYS_DIR
#     admin_private_key = "#{SSH_KEYS_DIR}/#{name}.rsa"
#     admin_public_key  = "#{admin_private_key}.pub"
#
#     if !File.exist? admin_private_key
#       puts "Generating new ssh key..."
#       %x[ ssh-keygen -t rsa -b 4096 -N "" -f #{admin_private_key} ]
#     end
#
#     ibmcloud_cli_init( region )
#     terraform_init()
#
#     # terraform 'vpc-infra', {
#     #   :resource_group_name => resource_group,
#     #   :vpc_name            => name,
#     #   :region_name         => region,
#     #   :zone_name           => zone,
#     #   :admin_public_key    => admin_public_key }
#
#     subnet_1_id = %x[ ibmcloud is subnets | tail -n +3 | awk '{ if ($2 == "subnet-1" && $8 == "#{name}") { print $1} }' ].chomp
#
#     # workaround for https://github.com/IBM-Cloud/terraform-provider-ibm/issues/1292
#     security_groups_map = {}
#     %x[ ibmcloud is sgs | awk '$5 == "#{name}"' | awk '{print $2" "$1}' ].chomp.each_line do | line |
#       name, id = line.split
#       security_groups_map[ name.to_sym ] = id
#     end
#
#     terraform 'installation-server', {
#       :vpc_name            => name,
#       :region_name         => region,
#       :subnet_id           => subnet_1_id,
#       :security_groups_map => security_groups_map }
#
#     terraform 'network-server', {
#       :vpc_name            => name,
#       :region_name         => region,
#       :subnet_id           => subnet_1_id ,
#       :security_groups_map => security_groups_map }
#   end
#
# elsif options[ 'add' ]
#   puts 'Not implemented yet'
#   exit 1
#
# elsif options[ 'rm' ]
#   puts 'Not implemented yet'
#   exit 1
#
# end
#
# exit 0
