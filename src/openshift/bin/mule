#! /usr/bin/env ruby

require 'tempfile'
require 'open3'
require 'docopt'

# set env variable IBMCLOUD_API_KEY with your key
ENV[ 'IBMCLOUD_COLOR' ] = 'false'

  HOME_DIR = File.expand_path( "#{File.dirname __FILE__}/.." )
 STATE_DIR = Dir.pwd
STATE_FILE = "#{STATE_DIR}/terraform.tfstate"
 VARS_FILE = "#{STATE_DIR}/terraform.tfvars"

def quit( msg )
  puts msg
  exit 1
end

def load_vars_file( vars_file = VARS_FILE )
  vars = {}
  if File.exist? vars_file
    File.readlines( vars_file ).each do | line |
      k, v = line.split ' = '
      vars[ k.to_sym ] = v.tr "\"\n", ''
    end
  end
  vars
end

def store_vars_file( vars, vars_file = VARS_FILE )
  File.open vars_file, 'w' do | f |
    vars.each do | k, v |
      f.write "#{k} = \"#{v}\"\n"
    end
  end
end

def terraform( dir, new_vars = nil )

  # merge existing terraform vars with this run's vars
  vars   = load_vars_file
  merged = vars.merge new_vars
  store_vars_file merged

  # prepare command
  Dir.chdir "#{HOME_DIR}/#{dir}"
  %x[ terraform init ]

  cmd = <<-EOT.gsub( /\s+/, ' ' ).strip
    terraform apply
      -auto-approve
      -state #{STATE_FILE}
      -var ibmcloud_api_key=#{ENV[ 'IBMCLOUD_API_KEY']}
      -var-file #{VARS_FILE}
      -compact-warnings
  EOT

  # run terraform
  status = nil
  Open3.popen2e( cmd ) do | stdin, stdout_err, wait_thread |
    while line = stdout_err.gets
      puts line
    end
    status = wait_thread.value
  end

  status.exitstatus
end # terraform

# ---- MAIN ----

usage = <<~DOC
  USAGE:
    mule new cluster --name=<name> --location=<loc>... --resource-group=<grp> --ssh-key=<key>
    mule add node    --name=<name> --type=<type> [--profile=<profile>] [--location=<loc>]
    mule rm  node    --name=<name> [--force]

  OPTIONS:
    --name=<name>           The name of the newly created resource
    --location=<loc>        The location of the resource, given as region:zone[:subnet]
    --resource-group=<grp>  Add the newly created cluster to this resource group
    --ssh-key=<key>         The name of the ssh key used to admin the resources
    --profile=<profile>     The profile of the machine
    --type=<type>           The type of the node, one of (bootstrap|master|worker)
  DOC

begin
  options = Docopt::docopt( usage )
rescue Docopt::Exit => e
  puts usage
  exit 1
end

if options[ 'new' ]

  # new cluster
  if options[ 'cluster' ]
    puts "Creating new cluster..."

    cluster_name   = options[ '--name' ]
    leg_1_vpc      = cluster_name
    resource_group = options[ '--resource-group' ]
    ssh_key        = options[ '--ssh-key' ]

    locations = options[ '--location' ]
    quit 'Error, only a single location is supported at this time' if locations.size != 1
    leg_1_region, leg_1_zone = locations[ 0 ].split ':'

    exit_status = terraform 'lib/cluster', {
      :cluster_name   => cluster_name,
      :leg_1_vpc      => leg_1_vpc,
      :leg_1_region   => leg_1_region,
      :leg_1_zone     => leg_1_zone,
      :resource_group => resource_group,
      :ssh_key        => ssh_key }

  end

elsif options[ 'add' ]

  # add node
  if options[ 'node' ]
    if options[ '--type' ] == 'bootstrap'
      puts "Adding new bootstrap node..."

      puts "Resolving resource ids..."
      vars = load_vars_file

      %x[ ibmcloud login --apikey #{ENV[ 'IBMCLOUD_API_KEY' ]} -r #{vars[ :leg_1_region ]}
          ibmcloud is target --gen 2 ]
      leg_1_subnet_1_id = %x[ ibmcloud is subnets | tail -n +3 | awk '{ if ($2 == "subnet-1" && $8 == "#{vars[ :leg_1_vpc ]}") { print $1} }' ].chomp

      exit_status = terraform 'lib/bootstrap', {
        :leg_1_subnet_1_id => leg_1_subnet_1_id
      }

    elsif options[ '--type' ] == 'master'
      puts "Adding new master node..."
    elsif options[ '--type' ] == 'worker'
      puts "Adding new worker node..."
    else
      puts 'Error, unrecognied node type'
    end
  end

elsif options[ 'rm' ]

  # rm node
  if options[ 'node' ]
    puts "Removing node..."
  end
end

exit 0


# if exitstatus == 0
#   %x[ ibmcloud login --apikey #{ENV[ 'IBMCLOUD_API_KEY' ]} -r #{leg_1_region}
#       ibmcloud is target --gen 2 ]
#
#   puts "Resolving resource ids..."
#   leg_1_subnet_1_id = %x[ ibmcloud is subnets | tail -n +3 | awk '{ if ($2 == "subnet-1" && $8 == "#{leg_1_vpc}") { print $1} }' ].chomp
#
#   File.open "#{STATE_DIR}/#{cluster_name}/vars.tfvars", "w" do | f |
#     f.write <<~EOT
#       cluster_name       = "#{cluster_name}"
#       resource_group     = "#{resource_group}"
#       leg_1_vpc          = "#{leg_1_vpc}"
#       leg_1_region       = "#{leg_1_region}"
#       leg_1_zone         = "#{leg_1_zone}"
#       leg_1_subnet_1_id  = "#{leg_1_subnet_1_id}"
#     EOT
#   end
# end





# puts "Logging in..."
# %x[ ibmcloud login --apikey #{ENV[ 'IBMCLOUD_API_KEY' ]} -r #{options[ '--region' ]}
#     ibmcloud is target --gen 2 ]
#
# puts "Resolving environment..."
# subnet_id = %x[ ibmcloud is subnets | tail -n +3 | awk '{ if ($2 == "#{options[ '--subnet' ]}" && $8 == "#{options[ '--vpc' ]}") { print $1} }' ].chomp
# bail "Error, can't find subnet: #{options[ '--subnet']}/#{options[ '--vpc']}/#{options[ '--region']}" if subnet_id.length == 0
#
# puts "region      = #{options[ '--region' ]}"
# puts "vpc         = #{options[ '--vpc' ] }"
# puts "subnet/id   = #{options[ '--subnet' ]}/#{subnet_id}"
#
# puts "Running terraform..."
# Dir.chdir '../lib/bootstrap-server'
#
# %x[ terraform init ]
#
# cmd = <<-EOT.gsub( /\s+/, ' ' ).strip
#   terraform apply -auto-approve
#     -var ibmcloud_api_key=#{ENV[ 'IBMCLOUD_API_KEY']}
#     -var region=#{options[ '--region' ]}
#     -var vpc=#{options[ '--vpc' ] }
#     -var subnet_id=#{subnet_id}
#     -var ssh_key=#{options[ '--ssh-key' ]}
# EOT
#
# Open3.popen2e( cmd ) do | stdin, stdout_err, wait_thread |
#   while line = stdout_err.gets
#     puts line
#   end
# end
